/*
 * Copyright 2017 LinkedIn Corp. Licensed under the BSD 2-Clause License (the "License"). See License in the project root for license information.
 *
 */

package com.linkedin.kafka.cruisecontrol.analyzer.goals;

import com.linkedin.kafka.cruisecontrol.analyzer.BalancingConstraint;
import com.linkedin.kafka.cruisecontrol.analyzer.BalancingProposal;
import com.linkedin.kafka.cruisecontrol.common.BalancingAction;
import com.linkedin.kafka.cruisecontrol.exception.AnalysisInputException;
import com.linkedin.kafka.cruisecontrol.exception.ModelInputException;
import com.linkedin.kafka.cruisecontrol.exception.OptimizationFailureException;
import com.linkedin.kafka.cruisecontrol.model.Broker;
import com.linkedin.kafka.cruisecontrol.model.ClusterModel;
import com.linkedin.kafka.cruisecontrol.model.ClusterModelStats;
import com.linkedin.kafka.cruisecontrol.model.Partition;
import com.linkedin.kafka.cruisecontrol.model.Replica;
import com.linkedin.kafka.cruisecontrol.monitor.ModelCompletenessRequirements;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;


/**
 * Class for achieving the following hard goal:
 * HARD GOAL: Generate replica and leadership movement proposals to provide even distribution of replicas similar to
 * even balance module in kafka-assigner.
 *
 * This goal performs balancing in two-phases for each partition of each topic. In the first phase, it balances partitions
 * of the same topic. In the second phase, it distributes the remainder partitions evenly among the brokers in round
 * robin distribution.
 *
 * @see <a href="https://github.com/linkedin/kafka-tools/blob/master/kafka/tools/assigner/actions/balancemodules/even.py">
 *   https://github.com/linkedin/kafka-tools/blob/master/kafka/tools/assigner/actions/balancemodules/even.py</a>
 *   for the original algorithm.
 */
public class EvenAssignerGoal extends AbstractGoal {
  private static final Logger LOG = LoggerFactory.getLogger(EvenAssignerGoal.class);
  // Typically Cruise Control ensures that if there are new brokers in the cluster, it only allows the replicas to be
  // moved to the new brokers. However, this goal cares about neither (1) the broker state, nor (2) the previously
  // optimized goals. Hence, if this goal is intended to be executed, it makes sense to make it the highest priority
  // goal. For goals that are executed after this goal, the eligibility check is skipped, as well.
  private final boolean skipEligibilityCheck = true;
  private Map<String, List<Partition>> _partitionsByTopic;

  /**
   * Constructor for Even Assigner Goal.
   */
  public EvenAssignerGoal() {

  }

  /**
   * Package private for unit test.
   */
  EvenAssignerGoal(BalancingConstraint constraint) {
    _balancingConstraint = constraint;
  }

  /**
   * Check whether the given proposal is acceptable by this goal. This goal is used to generate an initially balanced
   * distribution. Hence, it is acceptable to break the distribution generated by this goal for the sake of satisfying
   * the requirements of the other goals.
   *
   * @param proposal     Proposal to be checked for acceptance.
   * @param clusterModel The state of the cluster.
   * @return True if proposal is acceptable by this goal, false otherwise.
   */
  @Override
  public boolean isProposalAcceptable(BalancingProposal proposal, ClusterModel clusterModel) {
    return true;
  }

  @Override
  public ClusterModelStatsComparator clusterModelStatsComparator() {
    return new EvenAssignerGoal.EvenAssignerGoalStatsComparator();
  }

  @Override
  public ModelCompletenessRequirements clusterModelCompletenessRequirements() {
    // We only need the latest snapshot and include all the topics.
    return new ModelCompletenessRequirements(1, 0.0, true);
  }

  /**
   * Get the name of this goal. Name of a goal provides an identification for the goal in human readable format.
   */
  @Override
  public String name() {
    return EvenAssignerGoal.class.getSimpleName();
  }

  /**
   * Check if requirements of this goal are not violated if this proposal is applied to the given cluster state,
   * false otherwise.
   *
   * @param clusterModel The state of the cluster.
   * @param proposal     Proposal containing information about
   * @return True if requirements of this goal are not violated if this proposal is applied to the given cluster state,
   * false otherwise.
   */
  @Override
  protected boolean selfSatisfied(ClusterModel clusterModel, BalancingProposal proposal) {
    return true;
  }

  /**
   * This goal does not perform per-broker balancing; hence, this method is irrelevant.
   */
  @Override
  protected Collection<Broker> brokersToBalance(ClusterModel clusterModel) {
    return null;
  }

  /**
   * Get a list of deques for each position, containing the broker ids that the remainder replicas will be distributed
   * in round robin fashion.
   *
   * @param clusterModel The state of the cluster.
   * @return A list of deques containing the remainder broker ids for each position.
   */
  private List<Deque<Integer>> getRemainderBrokerIds(ClusterModel clusterModel) {
    PriorityQueue<Integer> orderedBrokerIds = new PriorityQueue<>(clusterModel.brokers().size());

    clusterModel.brokers().forEach(broker -> orderedBrokerIds.add(broker.id()));

    List<Deque<Integer>> remainderBrokerIds = new ArrayList<>();
    int maxReplicationFactor = clusterModel.maxReplicationFactor();
    for (int pos = 0; pos < maxReplicationFactor; pos++) {
      Deque<Integer> orderedBrokerDeque = new ArrayDeque<>(orderedBrokerIds);
      // Rotate the dequeue.
      for (int i = 0; i < pos; i++) {
        Integer brokerId = orderedBrokerDeque.removeFirst();
        orderedBrokerDeque.addLast(brokerId);
      }
      remainderBrokerIds.add(orderedBrokerDeque);
    }
    return remainderBrokerIds;
  }

  /**
   * Get a map of the number of replicas by broker id for each position, where the position represents the rank of a
   * replica in the replica list of a partition.
   *
   * @param clusterModel The state of the cluster.
   * @param topicName Topic name.
   * @param numPartitionsToMap The number of partitions to get a map of.
   * @return A map of the number of replicas by broker id for each position.
   */
  private List<Map<Integer, Integer>> getBrokerMap(ClusterModel clusterModel, String topicName, int numPartitionsToMap) {
    List<Map<Integer, Integer>> pmap = new ArrayList<>();
    for (int pos = 0; pos < clusterModel.replicationFactorByTopic().get(topicName); pos++) {
      Map<Integer, Integer> numReplicasInPositionByBrokerId = new HashMap<>();
      for (Broker broker: clusterModel.brokers()) {
        numReplicasInPositionByBrokerId.put(broker.id(), 0);
      }

      pmap.add(numReplicasInPositionByBrokerId);
    }

    for (int pnum = 0; pnum < numPartitionsToMap + 1; pnum++) {
      Partition partition = _partitionsByTopic.get(topicName).get(pnum);

      // Initialize leader count per broker.
      int leaderBrokerId = partition.leader().broker().id();
      pmap.get(0).put(leaderBrokerId, pmap.get(0).get(leaderBrokerId) + 1);

      // Initialize follower count per broker for each position -- i.e. first follower, second follower, and so on.
      int numFollowers = partition.followerBrokers().size();
      for (int followerPos = 1; followerPos <= numFollowers; followerPos++) {
        int followerBrokerId = partition.followerBrokers().get(followerPos - 1).id();
        pmap.get(followerPos).put(followerBrokerId, pmap.get(followerPos).get(followerBrokerId) + 1);
      }
    }
    return pmap;
  }

  /**
   * A check indicating whether the replicas in each position of the given partition map
   *
   * @param pmap Partition map indicating the number of replicas on each broker for each position.
   * @param target The intended number of replicas that a balanced broker should have at each position.
   * @return True if target requirement is satisfied, false otherwise.
   */
  private boolean pmapMatchesTarget(List<Map<Integer, Integer>> pmap, int target) {
    for (Map<Integer, Integer> numReplicasInPositionByBrokerId: pmap) {
      for (Map.Entry<Integer, Integer> entry: numReplicasInPositionByBrokerId.entrySet()) {
        if (entry.getValue() != target) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Get the position of follower that is part of the given partition and reside in the broker with the given id.
   *
   * @param partition The partition that the follower is a part of.
   * @param brokerId Id of the broker that the follower resides.
   * @return the position of follower that is part of the given partition and reside in the broker with the given id.
   */
  private int followerPosition(Partition partition, int brokerId) {
    int followerPos = 1;
    for (Broker follower: partition.followerBrokers()) {
      if (follower.id() == brokerId) {
        return followerPos;
      }
      followerPos++;
    }
    throw new IllegalArgumentException(String.format("Partition %s has no follower on %d.", partition, brokerId));
  }

  /**
   * This goal does not care about self-healing. Hence, if there are dead brokers, there will be replicas on those
   * brokers at the end of the distribution process.
   * This function performs all the balancing in one step.
   *
   * @param clusterModel The state of the cluster.
   * @param excludedTopics The topics that should be excluded from the optimization proposals.
   */
  @Override
  protected void initGoalState(ClusterModel clusterModel, Set<String> excludedTopics)
      throws AnalysisInputException, ModelInputException, OptimizationFailureException {
    LOG.debug("Starting even partition balance with excluded topics = {}", excludedTopics);

    // Initialize broker deques for each position for remainder assignment
    List<Deque<Integer>> remainderBrokerIds = getRemainderBrokerIds(clusterModel);
    // Initialize partitions by topic.
    _partitionsByTopic = clusterModel.getPartitionsByTopic();
    int numBrokers = clusterModel.brokers().size();
    for (String topicName: clusterModel.topics()) {
      if (excludedTopics.contains(topicName)) {
        LOG.warn("Skipping topic {} as it is explicitly excluded.", topicName);
        continue;
      }
      // How many partitions per broker, and what's the last one that can be evenly balanced.
      int numTopicPartitions = _partitionsByTopic.get(topicName).size();
      int lastEvenPartition = numTopicPartitions - (numTopicPartitions % numBrokers) - 1;

      // Balance all but the last remainder partitions.
      distributeAllExceptRemainder(lastEvenPartition, topicName, clusterModel);
      // Distribute the remainder partitions evenly among the brokers in round robin distribution.
      distributeRemainder(lastEvenPartition, topicName, clusterModel, remainderBrokerIds);
    }

    // Sanity check to confirm that partitions of each topic in the cluster are distributed evenly at each position.
    ensureEvenAssignment(clusterModel, excludedTopics);

    finish();
  }

  /**
   * Sanity check for even distribution.
   * For partitions of each topic in the cluster, the difference between the maximum and minimum number of replicas per
   * broker at each position cannot be larger than 1.
   *
   * @param clusterModel The state of the cluster.
   * @param excludedTopics The topics that should be excluded from the optimization proposals.
   */
  private void ensureEvenAssignment(ClusterModel clusterModel, Set<String> excludedTopics)
      throws OptimizationFailureException {
    for (String topicName: clusterModel.topics()) {
      if (excludedTopics.contains(topicName)) {
        LOG.warn("Skipping topic {} as it is explicitly excluded.", topicName);
        continue;
      }

      int numTopicPartitions = _partitionsByTopic.get(topicName).size();
      List<Map<Integer, Integer>> pmap = getBrokerMap(clusterModel, topicName, numTopicPartitions - 1);

      int position = 0;
      for (Map<Integer, Integer> numReplicasInPositionByBrokerId: pmap) {
        int maxPerBrokerReplicasInPosition = 0;
        int minPerBrokerReplicasInPosition = Integer.MAX_VALUE;
        for (Map.Entry<Integer, Integer> entry: numReplicasInPositionByBrokerId.entrySet()) {
          int numPerBrokerReplicasInPosition = entry.getValue();
          maxPerBrokerReplicasInPosition = Math.max(maxPerBrokerReplicasInPosition, numPerBrokerReplicasInPosition);
          minPerBrokerReplicasInPosition = Math.min(minPerBrokerReplicasInPosition, numPerBrokerReplicasInPosition);
        }

        // Ensure that the difference between max and min replica count in this position is less than 1.
        int difference = maxPerBrokerReplicasInPosition - minPerBrokerReplicasInPosition;
        if (difference > 1) {
          throw new OptimizationFailureException(
              String.format("Failed even partition assignment of topic: %s in position: %d. Replicas [max: %d, min %d]",
                            topicName, position, maxPerBrokerReplicasInPosition, minPerBrokerReplicasInPosition));
        }
        position++;
      }
    }
  }

  /**
   * Balance all but the last remainder partitions.
   *
   * @param lastEvenPartition The index of last partition to be balanced.
   * @param topicName Topic name.
   * @param clusterModel The state of the cluster.
   */
  private void distributeAllExceptRemainder(int lastEvenPartition, String topicName, ClusterModel clusterModel)
      throws AnalysisInputException, ModelInputException {
    // Initialize broker map for this topic.
    List<Map<Integer, Integer>> pmap = getBrokerMap(clusterModel, topicName, lastEvenPartition);
    int target = _partitionsByTopic.get(topicName).size() / clusterModel.brokers().size();

    while (!pmapMatchesTarget(pmap, target)) {
      for (int pnum = 0; pnum < lastEvenPartition + 1; pnum++) {
        Partition partition = _partitionsByTopic.get(topicName).get(pnum);

        // Track broker ids before a position change among replicas of a partition (if any) to prevent an infinite loop
        // caused by back and forth position swap within the same round -- i.e. while iterating over replicas of the
        // same partition.
        int numFollowers = partition.followerBrokers().size();
        int[] brokerIdBeforePositionChangeSortedByPosition = new int[numFollowers + 1];
        for (int pos = 0; pos < numFollowers + 1; pos++) {
          brokerIdBeforePositionChangeSortedByPosition[pos] = -1;
        }

        // Change leader or leadership placement if it is in a broker with more target leaders of the same partition.
        Broker leaderBroker = partition.leader().broker();
        if (pmap.get(0).get(leaderBroker.id()) > target) {

          // Find a new broker for the leader at this position or transfer its leadership.
          for (Integer brokerId: pmap.get(0).keySet()) {
            if (pmap.get(0).get(brokerId) >= target) {
              continue;
            }

            Broker destinationBroker = clusterModel.broker(brokerId);
            // Check if a follower of the same partition resides in the destination broker.
            if (partition.followerBrokers().contains(destinationBroker)) {
              // Move leadership to the follower.
              int otherPos = followerPosition(partition, brokerId);
              brokerIdBeforePositionChangeSortedByPosition[0] = leaderBroker.id();
              if (maybeApplyBalancingAction(clusterModel,
                                            partition.leader(),
                                            Collections.singletonList(destinationBroker),
                                            BalancingAction.LEADERSHIP_MOVEMENT,
                                            Collections.emptySet(),
                                            skipEligibilityCheck) == null) {
                throw new AnalysisInputException(String.format("Violated %s. Unable to move leadership from source"
                                                               + " %d to destination: %d",
                                                               name(), leaderBroker.id(), destinationBroker.id()));
              }
              pmap.get(otherPos).put(destinationBroker.id(), pmap.get(otherPos).get(destinationBroker.id()) - 1);
              pmap.get(otherPos).put(leaderBroker.id(), pmap.get(otherPos).get(leaderBroker.id()) + 1);
            } else {
              // Move leader to the destination broker.
              if (maybeApplyBalancingAction(clusterModel,
                                            partition.leader(),
                                            Collections.singletonList(destinationBroker),
                                            BalancingAction.REPLICA_MOVEMENT,
                                            Collections.emptySet(),
                                            skipEligibilityCheck) == null) {
                throw new AnalysisInputException(String.format("Violated %s. Unable to move leader from source"
                                                               + " %d to destination: %d",
                                                               name(), leaderBroker.id(), destinationBroker.id()));
              }
            }
            pmap.get(0).put(destinationBroker.id(), pmap.get(0).get(destinationBroker.id()) + 1);
            pmap.get(0).put(leaderBroker.id(), pmap.get(0).get(leaderBroker.id()) - 1);
            break;
          }
        }

        // Followers.
        for (int followerPos = 1; followerPos <= numFollowers; followerPos++) {
          Broker followerBroker = partition.followerBrokers().get(followerPos - 1);
          int followerBrokerId = followerBroker.id();
          if (pmap.get(followerPos).get(followerBrokerId) <= target) {
            continue;
          }

          // Find a new broker for the follower at this position or receive leadership.
          for (Integer destinationBrokerId: pmap.get(followerPos).keySet()) {
            if (pmap.get(followerPos).get(destinationBrokerId) >= target) {
              continue;
            }

            Broker destinationBroker = clusterModel.broker(destinationBrokerId);

            // Check if a replica of the same partition resides in the destination broker.
            if (partition.followerBrokers().contains(destinationBroker)) {
              // The destination broker has another follower. Unless this follower has just been swapped away from the
              // proposed position within the same round, i.e. while iterating over replicas of the same partition,
              // change the positions of replicas in the partition follower list. Note that swapping followers does not
              // actually move replicas within the cluster.
              int otherPos = followerPosition(partition, destinationBrokerId);
              if (brokerIdBeforePositionChangeSortedByPosition[otherPos] == followerBroker.id()) {
                continue;
              }
              brokerIdBeforePositionChangeSortedByPosition[followerPos] = followerBroker.id();

              partition.swapFollowerPositions(followerPos - 1, otherPos - 1);

              pmap.get(otherPos).put(destinationBrokerId, pmap.get(otherPos).get(destinationBrokerId) - 1);
              pmap.get(otherPos).put(followerBroker.id(), pmap.get(otherPos).get(followerBroker.id()) + 1);

            } else if (partition.leader().broker().id() == destinationBrokerId) {
              // The destination broker has the leader. Move leadership to the follower, unless this follower has just
              // given away its leadership to the current leader within the same round -- i.e. while iterating over
              // replicas of the same partition.
              if (brokerIdBeforePositionChangeSortedByPosition[0] == followerBroker.id()) {
                continue;
              }

              if (maybeApplyBalancingAction(clusterModel,
                                            partition.leader(),
                                            Collections.singletonList(followerBroker),
                                            BalancingAction.LEADERSHIP_MOVEMENT,
                                            Collections.emptySet(),
                                            skipEligibilityCheck) == null) {
                throw new AnalysisInputException(String.format("Violated %s. Unable to receive leadership from source"
                                                               + " %d  to destination: %d",
                                                               name(), destinationBrokerId, followerBroker.id()));
              }
              pmap.get(0).put(destinationBrokerId, pmap.get(0).get(destinationBrokerId) - 1);
              pmap.get(0).put(followerBroker.id(), pmap.get(0).get(followerBroker.id()) + 1);
            } else {
              // The destination broker has no replica from the same partition.
              Replica follower = partition.followers().get(followerPos - 1);
              if (maybeApplyBalancingAction(clusterModel,
                                            follower,
                                            Collections.singletonList(destinationBroker),
                                            BalancingAction.REPLICA_MOVEMENT,
                                            Collections.emptySet(),
                                            skipEligibilityCheck) == null) {
                throw new AnalysisInputException(String.format("Violated %s. Unable to move follower from source"
                                                               + " %d to destination: %d",
                                                               name(), followerBroker.id(), destinationBrokerId));
              }
            }
            pmap.get(followerPos).put(destinationBrokerId, pmap.get(followerPos).get(destinationBrokerId) + 1);
            pmap.get(followerPos).put(followerBroker.id(), pmap.get(followerPos).get(followerBroker.id()) - 1);
            break;
          }
        }
      }
    }
  }

  /**
   * Distribute the remainder partitions evenly among the brokers in round robin distribution.
   *
   * @param lastBalancedPartition The index of last balanced partition.
   * @param topicName Topic name.
   * @param clusterModel The state of the cluster.
   * @param remainderBrokerIds Broker ids for the remainder assignment.
   */
  private void distributeRemainder(int lastBalancedPartition,
                                   String topicName,
                                   ClusterModel clusterModel,
                                   List<Deque<Integer>> remainderBrokerIds)
      throws AnalysisInputException, ModelInputException {

    int numTopicPartitions = _partitionsByTopic.get(topicName).size();
    for (int pnum = lastBalancedPartition + 1; pnum < numTopicPartitions; pnum++) {
      Partition partition = _partitionsByTopic.get(topicName).get(pnum);

      // Change leader placement if it is in a broker with more target leaders of the same partition.
      Broker leaderBroker = partition.leader().broker();
      Integer proposed = remainderBrokerIds.get(0).removeFirst();
      remainderBrokerIds.get(0).addLast(proposed);
      Broker destinationBroker = clusterModel.broker(proposed);

      // Move leader or leadership unless the proposed destination is the same is the current broker.
      if (proposed != leaderBroker.id()) {
        if (partition.followerBrokers().contains(destinationBroker)) {
          // Move leadership to the follower in the destination broker.
          if (maybeApplyBalancingAction(clusterModel,
                                        partition.leader(),
                                        Collections.singletonList(destinationBroker),
                                        BalancingAction.LEADERSHIP_MOVEMENT,
                                        Collections.emptySet(),
                                        skipEligibilityCheck) == null) {
            throw new AnalysisInputException(String.format("Violated %s. Unable to move leadership from source %d to "
                                                           + "destination: %d", name(), leaderBroker.id(), proposed));
          }
        } else {
          // Move leader to the destination broker.
          if (maybeApplyBalancingAction(clusterModel,
                                        partition.leader(),
                                        Collections.singletonList(destinationBroker),
                                        BalancingAction.REPLICA_MOVEMENT,
                                        Collections.emptySet(),
                                        skipEligibilityCheck) == null) {
            throw new AnalysisInputException(String.format("Violated %s. Unable to move leader from source %d to "
                                                           + "destination: %d", name(), leaderBroker.id(), proposed));
          }
        }
      }

      // Followers.
      int numFollowers = partition.followerBrokers().size();
      for (int followerPos = 1; followerPos <= numFollowers; followerPos++) {
        Broker followerBroker = partition.followerBrokers().get(followerPos - 1);
        proposed = remainderBrokerIds.get(followerPos).removeFirst();
        remainderBrokerIds.get(followerPos).addLast(proposed);

        destinationBroker = clusterModel.broker(proposed);
        // Unless the proposed destination is the same is the current broker, do one of the following: (1) Move follower
        // to the destination, (2) move leadership from the destination to the follower, or (3) swap follower positions.
        if (proposed != followerBroker.id()) {
          // Check if a replica of the same partition resides in the destination broker.
          if (partition.followerBrokers().contains(destinationBroker)) {
            // The destination broker has another follower. Just change their position in partition follower list.
            // Do not actually swap followers by moving them across brokers in the cluster.
            int otherPos = followerPosition(partition, proposed);
            partition.swapFollowerPositions(followerPos - 1, otherPos - 1);
          } else if (partition.leader().broker().id() == proposed) {
            // Move leadership to the follower.
            if (maybeApplyBalancingAction(clusterModel,
                                          partition.leader(),
                                          Collections.singletonList(followerBroker),
                                          BalancingAction.LEADERSHIP_MOVEMENT,
                                          Collections.emptySet(),
                                          skipEligibilityCheck) == null) {
              throw new AnalysisInputException(String.format("Violated %s. Unable to receive leadership from source %d "
                                                             + "to destination: %d", name(), proposed, followerBroker.id()));
            }
          } else {
            // The destination broker has no replica from the same partition.
            Replica follower = partition.followers().get(followerPos - 1);
            if (maybeApplyBalancingAction(clusterModel,
                                          follower,
                                          Collections.singletonList(destinationBroker),
                                          BalancingAction.REPLICA_MOVEMENT,
                                          Collections.emptySet(),
                                          skipEligibilityCheck) == null) {
              throw new AnalysisInputException(String.format("Violated %s. Unable to move follower from source %d "
                                                             + "to destination: %d", name(), followerBroker.id(), proposed));
            }
          }
        }
      }
    }
  }

  /**
   * This goal does not perform per-broker balancing; hence, this method is irrelevant.
   */
  @Override
  protected void updateGoalState(ClusterModel clusterModel, Set<String> excludedTopics)
      throws AnalysisInputException, OptimizationFailureException {
    throw new IllegalAccessError("The update goal state method of even assigner goal shall not be accessed.");
  }

  /**
   * This goal does not perform per-broker balancing; hence, this method is irrelevant.
   */
  @Override
  protected void rebalanceForBroker(Broker broker,
                                    ClusterModel clusterModel,
                                    Set<Goal> optimizedGoals,
                                    Set<String> excludedTopics)
      throws AnalysisInputException, ModelInputException {
    throw new IllegalAccessError("The rebalance for broker method of even assigner goal shall not be accessed.");
  }

  private static class EvenAssignerGoalStatsComparator implements ClusterModelStatsComparator {

    @Override
    public int compare(ClusterModelStats stats1, ClusterModelStats stats2) {
      // This goal do not care about stats. The optimization would have already failed if the goal is not met.
      return 0;
    }

    @Override
    public String explainLastComparison() {
      return null;
    }
  }
}
